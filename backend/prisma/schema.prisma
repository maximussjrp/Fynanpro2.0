generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== USUÁRIOS E TENANTS ====================

model User {
  id                        String    @id @default(uuid())
  email                     String    @unique
  passwordHash              String
  fullName                  String
  role                      String    @default("owner") // owner, member, super_master
  isActive                  Boolean   @default(true)
  isEmailVerified           Boolean   @default(false)
  lastLoginAt               DateTime?
  createdAt                 DateTime  @default(now())
  updatedAt                 DateTime  @updatedAt
  deletedAt                 DateTime?
  
  // Campos para verificação de email
  emailVerificationToken    String?
  emailVerificationExpires  DateTime?
  
  // Campos para reset de senha
  passwordResetToken        String?
  passwordResetExpires      DateTime?

  ownedTenants      Tenant[]  @relation("TenantOwner")
  tenantUsers       TenantUser[]
  transactions      Transaction[]
  auditLogs         AuditLog[]
  refreshTokens     RefreshToken[]
}

model Tenant {
  id                    String    @id @default(uuid())
  ownerId               String
  name                  String
  slug                  String    @unique
  subscriptionPlan      String    @default("trial") // trial, basic, plus, premium, business
  subscriptionStatus    String    @default("active") // active, suspended, cancelled
  trialEndsAt           DateTime?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  deletedAt             DateTime?
  
  // Campos para integração Stripe
  stripeCustomerId      String?   // ID do cliente no Stripe
  stripeSubscriptionId  String?   // ID da assinatura no Stripe
  stripePriceId         String?   // ID do preço/plano no Stripe
  stripeCurrentPeriodEnd DateTime? // Fim do período atual da assinatura

  owner               User           @relation("TenantOwner", fields: [ownerId], references: [id])
  tenantUsers         TenantUser[]
  categories          Category[]
  bankAccounts        BankAccount[]
  paymentMethods      PaymentMethod[]
  transactions        Transaction[]
  recurringBills      RecurringBill[]
  recurringOccurrences RecurringBillOccurrence[]
  installmentPurchases InstallmentPurchase[]
  installments        Installment[]
  budgets             Budget[]
  triggerCategories   TriggerCategory[]
  notifications       Notification[]
  imports             Import[]
  savedFilters        SavedFilter[]
  auditLogs           AuditLog[]

  @@index([ownerId])
  @@index([subscriptionPlan])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
}

model TenantUser {
  id              String    @id @default(uuid())
  tenantId        String
  userId          String
  role            String    @default("member") // owner, member, viewer
  permissions     String?   // JSON com permissões customizadas
  invitedBy       String?
  acceptedAt      DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user            User      @relation(fields: [userId], references: [id])

  @@unique([tenantId, userId])
  @@index([userId])
}

// ==================== CATEGORIAS ====================

model Category {
  id          String    @id @default(uuid())
  tenantId    String
  parentId    String?
  name        String
  type        String    @default("expense") // expense, income
  level       Int       @default(1) // 1, 2, 3
  icon        String?
  color       String?
  isActive    Boolean   @default(true)
  order       Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  tenant      Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parent      Category?    @relation("CategoryChildren", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  children    Category[]   @relation("CategoryChildren")
  semantics   CategorySemantics?
  transactions Transaction[]
  recurringBills RecurringBill[]
  installmentPurchases InstallmentPurchase[]
  budgets     Budget[]
  triggerCategories TriggerCategory[]

  @@index([tenantId, parentId])
  @@index([type])
  @@index([tenantId, type, isActive])
  @@index([tenantId, isActive])
}

// ==================== SEMÂNTICA DE ENERGIA ====================

// CategorySemantics - Classificação energética de categorias
// Define como cada categoria impacta a vida financeira do usuário.
// Segue o CONTRATO OFICIAL em backend/src/contracts/ENERGY-CONTRACT.md
model CategorySemantics {
  id                String    @id @default(uuid())
  categoryId        String    @unique
  tenantId          String
  
  // Pesos de energia (soma DEVE ser 1.0)
  generatedWeight   Decimal   @default(0) @db.Decimal(5, 4) // Para receitas
  survivalWeight    Decimal   @default(0) @db.Decimal(5, 4) // Sobrevivência
  choiceWeight      Decimal   @default(0) @db.Decimal(5, 4) // Escolha
  futureWeight      Decimal   @default(0) @db.Decimal(5, 4) // Futuro
  lossWeight        Decimal   @default(0) @db.Decimal(5, 4) // Energia Perdida
  
  // Metadados
  isFixed           Boolean   @default(false) // Gasto fixo?
  isEssential       Boolean   @default(false) // Essencial para sobrevivência?
  isInvestment      Boolean   @default(false) // É investimento?
  
  // Status de validação
  validationStatus  String    @default("inferred") // validated, inferred, not_validated, default
  validatedAt       DateTime?
  validatedBy       String?   // User ID que validou
  justification     String?   // Justificativa para híbridos
  
  // Override do usuário?
  userOverride      Boolean   @default(false)
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  category          Category  @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([validationStatus])
  @@index([tenantId, validationStatus])
}

// ==================== CONTAS E PAGAMENTOS ====================

model BankAccount {
  id              String    @id @default(uuid())
  tenantId        String
  name            String
  type            String    // bank, wallet, credit_card, investment, other
  institution     String?   // Nubank, Inter, Bradesco, etc
  currentBalance  Decimal   @default(0) @db.Decimal(15, 2)
  initialBalance  Decimal   @default(0) @db.Decimal(15, 2)
  isActive        Boolean   @default(true)
  color           String?
  icon            String?
  order           Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?

  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  transactions    Transaction[]
  paymentMethods  PaymentMethod[]
  recurringBills  RecurringBill[]
  installments    Installment[]

  @@index([tenantId, isActive])
  @@index([tenantId, type])
}

model PaymentMethod {
  id              String    @id @default(uuid())
  tenantId        String
  bankAccountId   String?
  name            String
  type            String    // pix, credit_card, debit_card, boleto, cash, bank_transfer, automatic_debit
  lastFourDigits  String?   // Para cartões
  cardNetwork     String?   // visa, mastercard, elo, amex, etc.
  expirationDate  DateTime? // Data de vencimento do cartão
  isActive        Boolean   @default(true)
  order           Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?

  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  bankAccount     BankAccount? @relation(fields: [bankAccountId], references: [id])
  transactions    Transaction[]
  recurringBills  RecurringBill[]
  installments    Installment[]

  @@index([tenantId, isActive])
  @@index([tenantId, type, isActive])
}

// ==================== TRANSAÇÕES ====================

model Transaction {
  id              String    @id @default(uuid())
  tenantId        String
  userId          String
  type            String    // income, expense, transfer
  transactionType String    @default("single") // single, recurring, installment
  categoryId      String?
  bankAccountId   String?
  paymentMethodId String?
  destinationAccountId String? // Para transferências internas
  amount          Decimal   @db.Decimal(15, 2)
  originalAmount  Decimal?  @db.Decimal(15, 2) // Valor original (para parceladas)
  description     String?
  transactionDate DateTime
  dueDate         DateTime? // Data de vencimento
  paidDate        DateTime? // Data real do pagamento
  isPaidEarly     Boolean?  // Pago antecipado?
  isPaidLate      Boolean?  // Pago atrasado?
  daysEarlyLate   Int?      // Quantos dias antes/depois
  status          String    @default("completed") // completed, pending, cancelled, scheduled
  isRecurring     Boolean   @default(false)
  isFixed         Boolean   @default(true) // true = Fixa, false = Variável
  recurringBillId String?
  installmentId   String?
  
  // Campos para hierarquia pai/filho
  parentId        String?   // ID da transação pai (template)
  
  // Campos para transações RECORRENTES
  frequency       String?   // daily, weekly, biweekly, monthly, bimonthly, quarterly, semiannual, yearly
  frequencyInterval Int?    // A cada X períodos (ex: a cada 2 meses)
  totalOccurrences Int?     // Número total de ocorrências (null = infinito)
  currentOccurrence Int?    // Ocorrência atual (1, 2, 3...)
  occurrenceNumber Int?     // Número da ocorrência para ordenação
  startDate       DateTime? // Data de início da recorrência
  endDate         DateTime? // Data de fim (calculada ou manual)
  nextDueDate     DateTime? // Próxima data de vencimento
  alertDaysBefore Int?      // Dias antes para alertar
  autoGenerateNext Boolean? // Gerar próxima automaticamente
  
  // Campos para transações PARCELADAS
  totalInstallments Int?    // Total de parcelas
  installmentNumber Int?    // Número da parcela atual (1/12, 2/12...)
  hasDownPayment  Boolean?  // Tem entrada?
  downPaymentAmount Decimal? @db.Decimal(15, 2) // Valor da entrada
  
  // ══════════════════════════════════════════════════════════════════
  // SEMÂNTICA DE ENERGIA (Override por transação)
  // Ref: backend/src/contracts/ENERGY-CONTRACT.md
  // ══════════════════════════════════════════════════════════════════
  
  // Fonte da energia para esta transação
  energySource      String?   // 'category' (padrão) ou 'user_override'
  
  // Override de pesos (só usado se energySource = 'user_override')
  energySurvival    Decimal?  @db.Decimal(5, 4) // Peso Sobrevivência
  energyChoice      Decimal?  @db.Decimal(5, 4) // Peso Escolha
  energyFuture      Decimal?  @db.Decimal(5, 4) // Peso Futuro
  energyLoss        Decimal?  @db.Decimal(5, 4) // Peso Energia Perdida
  energyJustification String? // Justificativa do override
  
  // ══════════════════════════════════════════════════════════════════
  // FASE 2.4: OFX Import, Transfers & Anti-duplicação
  // ══════════════════════════════════════════════════════════════════
  
  // Import tracking
  importBatchId         String?   // UUID do lote de importação
  importSource          String?   // 'ofx', 'csv', 'xml', 'manual'
  externalFitId         String?   // FITID do OFX para dedupe
  rawDescription        String?   // Descrição original do extrato
  normalizedDescription String?   // Descrição normalizada para matching
  
  // Transfer detection
  isTransfer            Boolean   @default(false) // É transferência interna?
  transferGroupId       String?   // UUID para vincular pares (out/in)
  linkedTransactionId   String?   // Link direto para transação pareada
  
  // Transaction classification
  transactionKind       String    @default("bank") // bank, card, invoice_payment, transfer, fee, unknown
  
  // Energy exclusion
  excludedFromEnergy    Boolean   @default(false) // Exclui de cálculos de energia
  excludedReason        String?   // 'transfer', 'invoice_payment', 'user_excluded', 'duplicate'
  
  // Review status for imports
  needsReview           Boolean   @default(false) // Precisa revisão humana?
  reviewSuggestion      String?   // JSON: { action, confidence, reason }
  reviewedAt            DateTime? // Quando foi revisado
  reviewedBy            String?   // User ID que revisou
  
  tags            String?   // JSON array
  notes           String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?

  // Relações
  tenant          Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user            User         @relation(fields: [userId], references: [id])
  category        Category?    @relation(fields: [categoryId], references: [id])
  bankAccount     BankAccount? @relation(fields: [bankAccountId], references: [id])
  paymentMethod   PaymentMethod? @relation(fields: [paymentMethodId], references: [id])
  parent          Transaction? @relation("TransactionHierarchy", fields: [parentId], references: [id], onDelete: SetNull, onUpdate: NoAction)
  children        Transaction[] @relation("TransactionHierarchy")

  @@index([tenantId, transactionDate])
  @@index([categoryId])
  @@index([type, status])
  @@index([userId])
  @@index([tenantId, type, transactionDate])
  @@index([tenantId, status, transactionDate])
  @@index([tenantId, categoryId, transactionDate])
  @@index([bankAccountId, transactionDate])
  @@index([tenantId, dueDate, status])
  @@index([tenantId, isFixed, status])
  @@index([recurringBillId])
  @@index([parentId])
  @@index([transactionType])
  @@index([tenantId, transactionType, status])
  
  // FASE 2.4: OFX Import indexes
  @@index([tenantId, externalFitId])
  @@index([tenantId, importBatchId])
  @@index([tenantId, isTransfer])
  @@index([tenantId, excludedFromEnergy])
  @@index([tenantId, needsReview])
  @@index([transferGroupId])
}

// ==================== CONTAS FIXAS (RECORRENTES) ====================

model RecurringBill {
  id              String    @id @default(uuid())
  tenantId        String
  categoryId      String?
  bankAccountId   String?
  paymentMethodId String?
  name            String
  type            String    @default("expense") // income, expense
  amount          Decimal?  @db.Decimal(15, 2)
  isVariableAmount Boolean  @default(false)
  frequency       String    @default("monthly") // monthly, weekly, yearly
  dueDay          Int       // 1-31
  firstDueDate    DateTime?
  lastDueDate     DateTime?
  alertDaysBefore Int       @default(3)
  alertOnDueDay   Boolean   @default(true)
  alertIfOverdue  Boolean   @default(true)
  autoGenerate    Boolean   @default(true)
  monthsAhead     Int       @default(3) // Quantos meses gerar automaticamente
  isFixed         Boolean   @default(true) // true = Fixa, false = Variável
  isTemplate      Boolean   @default(false) // true = Template de onboarding, false = Conta real
  status          String    @default("active") // active, paused, cancelled
  notes           String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?

  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  category        Category? @relation(fields: [categoryId], references: [id])
  bankAccount     BankAccount? @relation(fields: [bankAccountId], references: [id])
  paymentMethod   PaymentMethod? @relation(fields: [paymentMethodId], references: [id])
  occurrences     RecurringBillOccurrence[]

  @@index([tenantId, status])
  @@index([dueDay])
  @@index([tenantId, status, dueDay])
  @@index([tenantId, type, status])
  @@index([tenantId, isFixed, status])
}

model RecurringBillOccurrence {
  id              String    @id @default(uuid())
  tenantId        String
  recurringBillId String
  dueDate         DateTime
  amount          Decimal   @db.Decimal(15, 2)
  paidDate        DateTime?
  paidAmount      Decimal?  @db.Decimal(15, 2)
  status          String    @default("pending") // pending, paid, overdue, skipped
  notes           String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime? // ADICIONADO: Soft delete para auditoria

  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  recurringBill   RecurringBill @relation(fields: [recurringBillId], references: [id], onDelete: Cascade)

  @@index([tenantId, dueDate, status])
  @@index([recurringBillId])
  @@index([tenantId, status, dueDate])
  @@index([tenantId, deletedAt]) // ADICIONADO: Index para queries com soft delete
}

// ==================== PARCELADAS ====================

model InstallmentPurchase {
  id                  String    @id @default(uuid())
  tenantId            String
  categoryId          String?
  name                String
  description         String?
  totalAmount         Decimal   @db.Decimal(15, 2)
  numberOfInstallments Int
  installmentAmount   Decimal   @db.Decimal(15, 2)
  firstDueDate        DateTime
  remainingBalance    Decimal   @db.Decimal(15, 2)
  paidInstallments    Int       @default(0)
  isFixed             Boolean   @default(false) // true = Fixa, false = Variável
  status              String    @default("active") // active, completed, cancelled
  notes               String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  deletedAt           DateTime?

  tenant              Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  category            Category? @relation(fields: [categoryId], references: [id])
  installments        Installment[]

  @@index([tenantId, status])
  @@index([tenantId, status, firstDueDate])
  @@index([tenantId, isFixed, status])
}

model Installment {
  id                  String    @id @default(uuid())
  tenantId            String
  installmentPurchaseId String
  bankAccountId       String?
  paymentMethodId     String?
  installmentNumber   Int
  dueDate             DateTime
  amount              Decimal   @db.Decimal(15, 2)
  paidDate            DateTime?
  paidAmount          Decimal?  @db.Decimal(15, 2)
  status              String    @default("pending") // pending, paid, overdue
  notes               String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  tenant              Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  installmentPurchase InstallmentPurchase @relation(fields: [installmentPurchaseId], references: [id], onDelete: Cascade)
  bankAccount         BankAccount? @relation(fields: [bankAccountId], references: [id])
  paymentMethod       PaymentMethod? @relation(fields: [paymentMethodId], references: [id])

  @@index([tenantId, dueDate, status])
  @@index([installmentPurchaseId])
  @@index([tenantId, status, dueDate])
}

// ==================== ORÇAMENTOS ====================

model Budget {
  id              String    @id @default(uuid())
  tenantId        String
  categoryId      String
  name            String
  amount          Decimal   @db.Decimal(15, 2)
  period          String    @default("monthly") // monthly, quarterly, semester, annual
  startDate       DateTime
  endDate         DateTime
  alertAt80       Boolean   @default(true)
  alertAt90       Boolean   @default(true)
  alertAt100      Boolean   @default(true)
  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  category        Category  @relation(fields: [categoryId], references: [id])

  @@index([tenantId, categoryId, isActive])
  @@index([startDate, endDate])
  @@index([tenantId, isActive, startDate])
  @@index([tenantId, period, isActive])
}

// ==================== CONTROLE DE VÍCIOS/GATILHOS ====================

model TriggerCategory {
  id              String    @id @default(uuid())
  tenantId        String
  categoryId      String
  monthlyLimit    Decimal?  @db.Decimal(15, 2)
  alertMessage    String?
  trackingEnabled Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  category        Category  @relation(fields: [categoryId], references: [id])

  @@unique([tenantId, categoryId])
}

model Notification {
  id              String    @id @default(uuid())
  tenantId        String
  userId          String?
  type            String    // budget_alert, bill_due, overdue, goal_reached, payment_due, low_balance
  title           String
  message         String
  isRead          Boolean   @default(false)
  priority        String    @default("normal") // low, normal, high, urgent
  relatedId       String?   // ID do recurso relacionado
  relatedType     String?   // budget, bill, transaction, recurring_bill, installment
  actionUrl       String?   // URL para ação rápida
  transactionId   String?   // Link direto para transação
  createdAt       DateTime  @default(now())

  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, userId, isRead])
  @@index([createdAt])
  @@index([tenantId, isRead, createdAt])
  @@index([type, isRead])
}

// ==================== IMPORTAÇÕES ====================

model Import {
  id              String    @id @default(uuid())
  tenantId        String
  userId          String?
  fileName        String
  fileType        String    // csv, ofx, pdf
  bankAccountId   String?   // Conta de destino
  status          String    @default("pending") // pending, processing, completed, failed, needs_review
  totalRows       Int?
  processedRows   Int       @default(0)
  errorRows       Int       @default(0)
  errorLog        String?   // JSON
  
  // FASE 2.4: Estatísticas de import
  createdCount    Int       @default(0)  // Transações criadas
  dedupedCount    Int       @default(0)  // Duplicadas ignoradas
  transferPairs   Int       @default(0)  // Pares de transferência detectados
  invoicePayments Int       @default(0)  // Pagamentos de fatura detectados
  needsReviewCount Int      @default(0)  // Itens que precisam revisão
  excludedFromEnergyCount Int @default(0) // Itens excluídos de energia
  
  createdAt       DateTime  @default(now())
  completedAt     DateTime?

  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, status])
  @@index([tenantId, createdAt])
}

// ==================== FILTROS SALVOS ====================

model SavedFilter {
  id              String    @id @default(uuid())
  tenantId        String
  userId          String?
  name            String
  filterType      String    // transaction, report, budget
  filterData      String    // JSON com os filtros
  isPublic        Boolean   @default(false)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, filterType])
}

// ==================== AUDIT LOG (SUPER MASTER) ====================

model AuditLog {
  id              String    @id @default(uuid())
  tenantId        String?
  userId          String
  action          String    // login, view_as_user, create, update, delete
  resourceType    String?   // user, tenant, transaction, etc
  resourceId      String?
  ipAddress       String?
  userAgent       String?
  changes         String?   // JSON com mudanças
  createdAt       DateTime  @default(now())

  tenant          Tenant?   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user            User      @relation(fields: [userId], references: [id])

  @@index([tenantId, createdAt])
  @@index([userId, action])
  @@index([createdAt])
}

// ==================== REFRESH TOKENS ====================

model RefreshToken {
  id              String    @id @default(uuid())
  userId          String
  token           String    @unique
  expiresAt       DateTime
  isRevoked       Boolean   @default(false)
  revokedAt       DateTime?
  revokedReason   String?   // logout, security, password_change, etc
  ipAddress       String?
  userAgent       String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRevoked])
  @@index([token])
  @@index([expiresAt])
  @@index([userId, isRevoked, expiresAt])
}

// ==================== ADMIN LOGS ====================

model AdminLog {
  id              String    @id @default(uuid())
  adminId         String
  action          String
  targetType      String
  targetId        String
  description     String
  previousValue   String?   // JSON
  newValue        String?   // JSON
  ipAddress       String?
  userAgent       String?
  createdAt       DateTime  @default(now())

  @@index([adminId])
  @@index([action])
  @@index([targetType, targetId])
  @@index([createdAt])
}

// ==================== SYSTEM CONFIG ====================

model SystemConfig {
  id              String    @id @default(uuid())
  key             String    @unique
  value           String
  description     String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([key])
}

// ==================== SYSTEM ANNOUNCEMENTS ====================

model SystemAnnouncement {
  id              String    @id @default(uuid())
  title           String
  content         String
  type            String    @default("info") // info, warning, success, error
  targetPlans     String?   // JSON array de planos, null = todos
  isActive        Boolean   @default(true)
  startsAt        DateTime?
  endsAt          DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([isActive])
  @@index([startsAt, endsAt])
}

// ==================== CHATBOT ====================

// Sessão do chatbot - persistida para manter contexto entre sessões
model ChatSession {
  id              String    @id @default(uuid())
  tenantId        String
  userId          String
  state           String    @default("idle") // Estado atual do chatbot
  context         String?   // JSON com contexto da sessão (tempTransaction, etc)
  learnedPatterns String?   // JSON com padrões aprendidos do usuário
  lastActiveAt    DateTime  @default(now())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  messages        ChatMessage[]

  @@unique([tenantId, userId])
  @@index([tenantId])
  @@index([userId])
  @@index([lastActiveAt])
}

// Histórico de mensagens do chatbot
model ChatMessage {
  id              String    @id @default(uuid())
  sessionId       String
  role            String    // 'user' ou 'assistant'
  content         String
  options         String?   // JSON array de opções mostradas
  quickReplies    String?   // JSON array de quick replies
  metadata        String?   // JSON com dados extras (navigate, etc)
  createdAt       DateTime  @default(now())

  session         ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, createdAt])
  @@index([sessionId])
}
